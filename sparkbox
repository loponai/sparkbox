#!/usr/bin/env bash
# ==========================================
# SparkBox CLI
# Modular self-hosted privacy stack manager
# Created by Tom Spark | youtube.com/@TomSparkReviews
# ==========================================

set -euo pipefail

# --- Config ---
SB_ROOT="${SB_ROOT:-/opt/sparkbox}"
SB_STATE_DIR="${SB_ROOT}/state"
SB_MODULES_DIR="${SB_ROOT}/modules"
SB_MODULES_CONF="${SB_STATE_DIR}/modules.conf"
SB_ENV_FILE="${SB_ROOT}/.env"
SB_BACKUP_DIR="${SB_ROOT}/backups"
SB_VERSION="1.0.0"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# --- Helpers ---

log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_ok() { echo -e "${GREEN}[OK]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }

banner() {
    echo -e "${CYAN}"
    echo "  ____                   _    ____            "
    echo " / ___| _ __   __ _ _ __| | _| __ )  _____  __"
    echo " \\___ \\| '_ \\ / _\` | '__| |/ /  _ \\ / _ \\ \\/ /"
    echo "  ___) | |_) | (_| | |  |   <| |_) | (_) >  < "
    echo " |____/| .__/ \\__,_|_|  |_|\\_\\____/ \\___/_/\\_\\"
    echo "       |_|                                     "
    echo -e "${NC}"
    echo -e " ${BOLD}SparkBox${NC} v${SB_VERSION} - Self-Hosted Privacy Stack"
    echo -e " Created by Tom Spark | youtube.com/@TomSparkReviews"
    echo ""
}

ensure_state_dir() {
    mkdir -p "${SB_STATE_DIR}"
    if [[ ! -f "${SB_MODULES_CONF}" ]]; then
        # Default: only core modules
        echo "core" > "${SB_MODULES_CONF}"
        echo "dashboard" >> "${SB_MODULES_CONF}"
    fi
}

get_enabled_modules() {
    ensure_state_dir
    cat "${SB_MODULES_CONF}" 2>/dev/null | sort -u
}

is_module_enabled() {
    local module="$1"
    grep -qx "${module}" "${SB_MODULES_CONF}" 2>/dev/null
}

# --- Dynamic module discovery ---

# List all module directories that contain a docker-compose.yml
discover_modules() {
    for dir in "${SB_MODULES_DIR}"/*/; do
        local name
        name=$(basename "${dir}")
        if [[ -f "${dir}docker-compose.yml" ]]; then
            echo "${name}"
        fi
    done
}

# Read a scalar field from x-sparkbox metadata using sed/grep (no dependencies)
read_sparkbox_field() {
    local module="$1"
    local field="$2"
    local compose="${SB_MODULES_DIR}/${module}/docker-compose.yml"
    [[ -f "${compose}" ]] || return

    # Extract value after "field:" within x-sparkbox block
    sed -n '/^x-sparkbox:/,/^[a-z]/p' "${compose}" | \
        grep -E "^  ${field}:" | head -1 | \
        sed "s/^  ${field}:[[:space:]]*//" | \
        sed 's/^"\(.*\)"$/\1/' | sed "s/^'\(.*\)'$/\1/"
}

# Get core modules (required: true in x-sparkbox)
get_core_modules() {
    for mod in $(discover_modules); do
        local required
        required=$(read_sparkbox_field "${mod}" "required")
        if [[ "${required}" == "true" ]]; then
            echo "${mod}"
        fi
    done
}

# Get optional modules (required: false or not set)
get_optional_modules() {
    for mod in $(discover_modules); do
        local required
        required=$(read_sparkbox_field "${mod}" "required")
        if [[ "${required}" != "true" ]]; then
            echo "${mod}"
        fi
    done
}

is_core_module() {
    local module="$1"
    local required
    required=$(read_sparkbox_field "${module}" "required")
    [[ "${required}" == "true" ]]
}

is_valid_module() {
    local module="$1"
    [[ -f "${SB_MODULES_DIR}/${module}/docker-compose.yml" ]]
}

get_compose_args() {
    local args=""
    local project_name="sparkbox"

    for module in $(get_enabled_modules); do
        local compose_file="${SB_MODULES_DIR}/${module}/docker-compose.yml"
        if [[ -f "${compose_file}" ]]; then
            args="${args} -f ${compose_file}"
        else
            log_warn "Compose file not found for module: ${module}"
        fi
    done

    echo "-p ${project_name} ${args}"
}

# Safely load .env file for CLI variable access (handles spaces in values)
load_env() {
    if [[ -f "${SB_ENV_FILE}" ]]; then
        while IFS= read -r line; do
            [[ -z "$line" || "$line" =~ ^[[:space:]]*# ]] && continue
            export "$line"
        done < "${SB_ENV_FILE}"
    fi
}

run_compose() {
    local compose_args
    compose_args=$(get_compose_args)

    if [[ -f "${SB_ENV_FILE}" ]]; then
        # shellcheck disable=SC2086
        docker compose --env-file "${SB_ENV_FILE}" ${compose_args} "$@"
    else
        # shellcheck disable=SC2086
        docker compose ${compose_args} "$@"
    fi
}

# --- Commands ---

cmd_up() {
    banner
    log_info "Starting SparkBox..."
    log_info "Active modules: $(get_enabled_modules | tr '\n' ' ')"
    echo ""
    run_compose up -d "$@"
    echo ""
    log_ok "SparkBox is running!"
    echo ""
    cmd_urls
}

cmd_down() {
    log_info "Stopping SparkBox..."
    run_compose down "$@"
    log_ok "SparkBox stopped."
}

cmd_status() {
    banner
    echo -e "${BOLD}Module Status:${NC}"
    echo ""

    for module in $(discover_modules); do
        local title
        title=$(read_sparkbox_field "${module}" "title")
        [[ -z "${title}" ]] && title="${module}"
        if is_module_enabled "${module}"; then
            echo -e "  ${GREEN}●${NC} ${BOLD}${module}${NC} (enabled) - ${title}"
        else
            echo -e "  ${RED}○${NC} ${module} (disabled) - ${title}"
        fi
    done

    echo ""
    echo -e "${BOLD}Container Status:${NC}"
    echo ""
    docker ps --filter "name=sb-" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" 2>/dev/null || \
        log_warn "Could not query Docker. Is Docker running?"
}

cmd_modules() {
    banner
    echo -e "${BOLD}Available Modules:${NC}"
    echo ""

    echo -e "  ${BOLD}Always Active:${NC}"
    for module in $(get_core_modules); do
        local title tagline
        title=$(read_sparkbox_field "${module}" "title")
        tagline=$(read_sparkbox_field "${module}" "tagline")
        [[ -z "${title}" ]] && title="${module}"
        echo -e "    ${GREEN}●${NC} ${BOLD}${module}${NC} - ${title}${tagline:+ — ${tagline}}"
    done

    echo ""
    echo -e "  ${BOLD}Optional:${NC}"
    for module in $(get_optional_modules); do
        local title tagline
        title=$(read_sparkbox_field "${module}" "title")
        tagline=$(read_sparkbox_field "${module}" "tagline")
        [[ -z "${title}" ]] && title="${module}"

        if is_module_enabled "${module}"; then
            echo -e "    ${GREEN}●${NC} ${BOLD}${module}${NC} - ${title}${tagline:+ — ${tagline}}"
        else
            echo -e "    ${RED}○${NC} ${module} - ${title}${tagline:+ — ${tagline}}"
        fi
    done
    echo ""
}

cmd_enable() {
    local module="${1:-}"
    if [[ -z "${module}" ]]; then
        log_error "Usage: sparkbox enable <module>"
        echo "Available modules:"
        get_optional_modules | while read -r m; do
            local title
            title=$(read_sparkbox_field "${m}" "title")
            echo "  ${m} - ${title}"
        done
        exit 1
    fi

    if ! is_valid_module "${module}"; then
        log_error "Unknown module: ${module}"
        echo "Available modules:"
        get_optional_modules | while read -r m; do
            local title
            title=$(read_sparkbox_field "${m}" "title")
            echo "  ${m} - ${title}"
        done
        exit 1
    fi

    if is_core_module "${module}"; then
        log_warn "${module} is a core module and is always enabled."
        return
    fi

    if is_module_enabled "${module}"; then
        log_warn "${module} is already enabled."
        return
    fi

    ensure_state_dir
    echo "${module}" >> "${SB_MODULES_CONF}"
    log_ok "Module '${module}' enabled."
    log_info "Run 'sparkbox up' to start the new module."
}

cmd_disable() {
    local module="${1:-}"
    if [[ -z "${module}" ]]; then
        log_error "Usage: sparkbox disable <module>"
        exit 1
    fi

    if is_core_module "${module}"; then
        log_error "Cannot disable core module: ${module}"
        exit 1
    fi

    if ! is_module_enabled "${module}"; then
        log_warn "${module} is not enabled."
        return
    fi

    # Stop the module's containers first
    local compose_file="${SB_MODULES_DIR}/${module}/docker-compose.yml"
    if [[ -f "${compose_file}" ]]; then
        log_info "Stopping ${module} containers..."
        if [[ -f "${SB_ENV_FILE}" ]]; then
            docker compose --env-file "${SB_ENV_FILE}" -p sparkbox -f "${compose_file}" down 2>/dev/null || true
        else
            docker compose -p sparkbox -f "${compose_file}" down 2>/dev/null || true
        fi
    fi

    # Remove from modules.conf
    local tmp
    tmp=$(mktemp)
    grep -vx "${module}" "${SB_MODULES_CONF}" > "${tmp}" || true
    mv "${tmp}" "${SB_MODULES_CONF}"

    log_ok "Module '${module}' disabled."
}

cmd_restart() {
    local module="${1:-}"

    if [[ -z "${module}" ]]; then
        log_info "Restarting all SparkBox services..."
        run_compose restart
    else
        if ! is_valid_module "${module}"; then
            log_error "Unknown module: ${module}"
            exit 1
        fi

        local compose_file="${SB_MODULES_DIR}/${module}/docker-compose.yml"
        if [[ -f "${compose_file}" ]]; then
            log_info "Restarting module: ${module}"
            if [[ -f "${SB_ENV_FILE}" ]]; then
                docker compose --env-file "${SB_ENV_FILE}" -p sparkbox -f "${compose_file}" restart
            else
                docker compose -p sparkbox -f "${compose_file}" restart
            fi
        fi
    fi

    log_ok "Restart complete."
}

cmd_update() {
    local module="${1:-}"

    if [[ -z "${module}" ]]; then
        log_info "Pulling latest images for all enabled modules..."
        run_compose pull
        log_info "Recreating containers..."
        run_compose up -d --force-recreate
    else
        if ! is_valid_module "${module}"; then
            log_error "Unknown module: ${module}"
            exit 1
        fi

        local compose_file="${SB_MODULES_DIR}/${module}/docker-compose.yml"
        if [[ -f "${compose_file}" ]]; then
            log_info "Updating module: ${module}"
            if [[ -f "${SB_ENV_FILE}" ]]; then
                docker compose --env-file "${SB_ENV_FILE}" -p sparkbox -f "${compose_file}" pull
                docker compose --env-file "${SB_ENV_FILE}" -p sparkbox -f "${compose_file}" up -d --force-recreate
            else
                docker compose -p sparkbox -f "${compose_file}" pull
                docker compose -p sparkbox -f "${compose_file}" up -d --force-recreate
            fi
        fi
    fi

    log_ok "Update complete."
}

cmd_logs() {
    local service="${1:-}"

    if [[ -z "${service}" ]]; then
        log_error "Usage: sparkbox logs <service>"
        echo "Examples: sparkbox logs sb-pihole"
        exit 1
    fi

    docker logs -f --tail 100 "${service}"
}

cmd_backup() {
    local timestamp
    timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="${SB_BACKUP_DIR}/sparkbox-backup-${timestamp}.tar.gz"

    mkdir -p "${SB_BACKUP_DIR}"

    log_info "Creating backup..."
    log_info "This may take a while depending on data size."

    # Backup state, env, and all module configs (not media data)
    tar -czf "${backup_file}" \
        -C "${SB_ROOT}" \
        state \
        .env \
        modules/*/config 2>/dev/null || true

    if [[ -f "${backup_file}" ]]; then
        local size
        size=$(du -h "${backup_file}" | cut -f1)
        log_ok "Backup created: ${backup_file} (${size})"
    else
        log_error "Backup failed."
        exit 1
    fi
}

cmd_restore() {
    local backup_file="${1:-}"

    if [[ -z "${backup_file}" ]]; then
        log_error "Usage: sparkbox restore <backup-file>"
        if [[ -d "${SB_BACKUP_DIR}" ]]; then
            echo ""
            echo "Available backups:"
            ls -lh "${SB_BACKUP_DIR}"/sparkbox-backup-*.tar.gz 2>/dev/null || echo "  No backups found."
        fi
        exit 1
    fi

    if [[ ! -f "${backup_file}" ]]; then
        log_error "Backup file not found: ${backup_file}"
        exit 1
    fi

    log_warn "This will overwrite current configuration!"
    read -rp "Continue? [y/N] " confirm
    if [[ "${confirm}" != "y" && "${confirm}" != "Y" ]]; then
        log_info "Restore cancelled."
        exit 0
    fi

    log_info "Stopping SparkBox..."
    run_compose down 2>/dev/null || true

    log_info "Restoring from backup..."
    tar -xzf "${backup_file}" -C "${SB_ROOT}"

    log_ok "Restore complete. Run 'sparkbox up' to start."
}

cmd_config() {
    if [[ -f "${SB_ROOT}/scripts/setup.sh" ]]; then
        bash "${SB_ROOT}/scripts/setup.sh"
    else
        log_error "Setup script not found. Please reinstall SparkBox."
        exit 1
    fi
}

cmd_urls() {
    load_env
    echo -e "${BOLD}Service URLs:${NC}"
    echo ""

    local domain="${SB_DOMAIN:-localhost}"

    for module in $(get_enabled_modules); do
        local compose_file="${SB_MODULES_DIR}/${module}/docker-compose.yml"
        [[ -f "${compose_file}" ]] || continue

        local title
        title=$(read_sparkbox_field "${module}" "title")
        [[ -z "${title}" ]] && title="${module}"

        # Extract port mappings from compose file services
        local ports_output=""
        while IFS= read -r line; do
            local container port svc_name
            container=$(echo "${line}" | awk '{print $1}')
            port=$(echo "${line}" | awk '{print $2}')
            svc_name=$(echo "${line}" | awk '{for(i=3;i<=NF;i++) printf "%s ", $i; print ""}' | sed 's/ *$//')

            [[ -z "${port}" || "${port}" == "null" ]] && continue
            ports_output="${ports_output}    ${svc_name:-${container}}: http://${domain}:${port}\n"
        done < <(
            # Use sed/awk to extract service key + port_map from x-sparkbox.services
            sed -n '/^x-sparkbox:/,/^[a-z]/p' "${compose_file}" | \
            sed -n '/^  services:/,/^  [a-z]/p' | \
            awk '
                /^    [a-z]/ { svc=$1; sub(/:$/,"",svc) }
                /port_map:/ && !/null/ { port=$2; }
                /friendly_name:/ { gsub(/"/,"",$0); fname=""; for(i=2;i<=NF;i++) fname=fname (i>2?" ":"") $i }
                /port_map:/ && !/null/ { print "sb-" svc " " port " " fname; fname="" }
            '
        )

        if [[ -n "${ports_output}" ]]; then
            echo -e "  ${BOLD}${title}:${NC}"
            echo -e "${ports_output}"
        fi
    done
}

cmd_install() {
    if [[ -f "${SB_ROOT}/scripts/setup.sh" ]]; then
        banner
        bash "${SB_ROOT}/scripts/setup.sh"
    else
        log_error "Setup script not found."
        exit 1
    fi
}

cmd_help() {
    banner
    echo -e "${BOLD}Usage:${NC} sparkbox <command> [options]"
    echo ""
    echo -e "${BOLD}Commands:${NC}"
    echo "  install              Run initial setup wizard"
    echo "  up                   Start all enabled modules"
    echo "  down                 Stop everything"
    echo "  status               Show all service statuses"
    echo "  modules              List available/enabled modules"
    echo "  enable <module>      Enable and configure a module"
    echo "  disable <module>     Stop and disable a module"
    echo "  restart [module]     Restart all or one module"
    echo "  update [module]      Pull latest images, recreate containers"
    echo "  logs <service>       Tail container logs"
    echo "  backup               Create backup archive"
    echo "  restore <file>       Restore from backup"
    echo "  config               Re-run configuration wizard"
    echo "  urls                 Show service URLs"
    echo "  help                 Show this help"
    echo ""
    echo -e "${BOLD}Modules:${NC}"
    for mod in $(discover_modules); do
        local title required
        title=$(read_sparkbox_field "${mod}" "title")
        required=$(read_sparkbox_field "${mod}" "required")
        [[ -z "${title}" ]] && title="${mod}"
        if [[ "${required}" == "true" ]]; then
            echo "  ${mod}$(printf '%*s' $((16 - ${#mod})) '')${title} (always on)"
        else
            echo "  ${mod}$(printf '%*s' $((16 - ${#mod})) '')${title}"
        fi
    done
    echo ""
}

# --- Main ---

main() {
    local command="${1:-help}"
    shift 2>/dev/null || true

    case "${command}" in
        install)  cmd_install "$@" ;;
        up)       cmd_up "$@" ;;
        down)     cmd_down "$@" ;;
        status)   cmd_status "$@" ;;
        modules)  cmd_modules "$@" ;;
        enable)   cmd_enable "$@" ;;
        disable)  cmd_disable "$@" ;;
        restart)  cmd_restart "$@" ;;
        update)   cmd_update "$@" ;;
        logs)     cmd_logs "$@" ;;
        backup)   cmd_backup "$@" ;;
        restore)  cmd_restore "$@" ;;
        config)   cmd_config "$@" ;;
        urls)     cmd_urls "$@" ;;
        help|--help|-h)
                  cmd_help ;;
        version|--version|-v)
                  echo "SparkBox v${SB_VERSION}" ;;
        *)
            log_error "Unknown command: ${command}"
            echo "Run 'sparkbox help' for usage."
            exit 1
            ;;
    esac
}

main "$@"
